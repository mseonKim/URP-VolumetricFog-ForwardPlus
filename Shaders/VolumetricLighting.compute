#pragma enable_d3d11_debug_symbols
#pragma kernel VolumetricLighting
#pragma multi_compile _ _FORWARD_PLUS

#include "./VolumetricLightingCommon.hlsl"


#define VBUFFER_VOXEL_SIZE 8
#define GROUP_SIZE_1D 8
#define TILE_SIZE_CLUSTERED 32  // NOTE: This assumes the screen size == FHD (1920 * 1080)
#define VBUFFER_SLICE_COUNT 64
// #define FLT_MIN  1.175494351e-38

RW_TEXTURE3D(float4, _VBufferLightingOutput);



[numthreads(GROUP_SIZE_1D, GROUP_SIZE_1D, 1)]
void VolumetricLighting(uint3 dispatchThreadId : SV_DispatchThreadID,
            uint2 groupId          : SV_GroupID,
            uint2 groupThreadId    : SV_GroupThreadID,
            int   groupIndex       : SV_GroupIndex)
{
    uint2  pixelPos  = groupId * GROUP_SIZE_1D + groupThreadId;
    float2 centerCoord = pixelPos + float2(0.5, 0.5);

    float3 F = -UNITY_MATRIX_V[2].xyz;
    float3 U = UNITY_MATRIX_V[1].xyz;
    float3 R = cross(F, U);

    float3 ClipSpace = float3(centerCoord * (_ScreenSize.zw * float2(VBUFFER_VOXEL_SIZE, VBUFFER_VOXEL_SIZE)) * float2(2.0, -2.0) - float2(1.0, -1.0), 1.0);
    float4 HViewPos = mul(unity_MatrixInvP, float4(ClipSpace, 1.0));
    float3 WorldDir = mul((float3x3)unity_MatrixInvV, HViewPos.xyz / HViewPos.w);

    float3 rayDirWS       = WorldDir; 
    float3 rightDirWS     = cross(rayDirWS, U);
    float  rcpLenRayDir   = rsqrt(dot(rayDirWS, rayDirWS));
    float  rcpLenRightDir = rsqrt(dot(rightDirWS, rightDirWS));

    JitteredRay ray;
    ray.originWS = _WorldSpaceCameraPos.xyz;
    ray.centerDirWS = rayDirWS * rcpLenRayDir;

    float FdotD = dot(F, ray.centerDirWS);
    float unitDistFaceSize = 0.00415f * FdotD * rcpLenRayDir;
    // float unitDistFaceSize = _VBufferUnitDepthTexelSpacing * FdotD * rcpLenRayDir;

    ray.xDirDerivWS = rightDirWS * (rcpLenRightDir * unitDistFaceSize); // Normalize & rescale
    ray.yDirDerivWS = cross(ray.xDirDerivWS, ray.centerDirWS); // Will have the length of 'unitDistFaceSize' by construction

#ifdef ENABLE_REPROJECTION
    // float2 sampleOffset = _VBufferSampleOffset.xy;
    float2 sampleOffset = float2(0.32946f, 0.08828f);
#else
    float2 sampleOffset = 0;
#endif

    ray.jitterDirWS = normalize(ray.centerDirWS + sampleOffset.x * ray.xDirDerivWS
                                                + sampleOffset.y * ray.yDirDerivWS);

    float tStart = _ProjectionParams.y / dot(ray.jitterDirWS, F); // _ProjectionParams.y = Near


    ray.geomDist = FLT_INF;
    ray.maxDist = FLT_INF;
    float deviceDepth = LoadSceneDepth(centerCoord);
    if (deviceDepth > 0) // Skip the skybox
    {
        // Convert it to distance along the ray. Doesn't work with tilt shift, etc.
        float linearDepth = LinearEyeDepth(deviceDepth, _ZBufferParams);
        ray.geomDist = linearDepth * rcp(dot(ray.jitterDirWS, F));

        // This should really be using a max sampler here. This is a bit overdilating given that it is already dilated.
        // Better to be safer though.
        // float4 d = GATHER_RED_TEXTURE2D_X(_MaxZMaskTexture, s_point_clamp_sampler, UV) * rcp(dot(ray.jitterDirWS, F));
        // ray.maxDist = max(Max3(d.x, d.y, d.z), d.w);
        ray.maxDist = ray.geomDist;
    }


    const float4 decodeDepthParams = GetDepthDecodingParam(2.0f);    // L, M, N

    float   t0 = max(tStart, DecodeLogarithmicDepthGeneralized(0, decodeDepthParams));
    float   de = rcp(VBUFFER_SLICE_COUNT); // TODO: Log-encoded distance between slices
    float3  totalRadiance = 0;
    float   opticalDepth = 0;
    float3  throughput = 1.0;
    float   anisotropy = 0.5;


    // Ray marching
    uint slice = 0;
    for (; slice < VBUFFER_SLICE_COUNT; slice++)
    {
        float e1 = slice * de + de; // (slice + 1) / sliceCount
        float t1 = max(tStart, DecodeLogarithmicDepthGeneralized(e1, decodeDepthParams));
        float tNext = t1;

        bool containsOpaqueGeometry = IsInRange(ray.geomDist, float2(t0, t1));
        if (containsOpaqueGeometry)
        {
            // Only integrate up to the opaque surface (make the voxel shorter, but not completely flat).
            // Note that we can NOT completely stop integrating when the ray reaches geometry, since
            // otherwise we get flickering at geometric discontinuities if reprojection is enabled.
            // In this case, a temporally stable light leak is better than flickering.
            t1 = max(t0 * 1.0001, ray.geomDist);
        }

        float dt = t1 - t0;
        if (dt <= 0.0)
        {
            t0 = t1;
            continue;
        }

        float  t = DecodeLogarithmicDepthGeneralized(e1 - 0.5 * de, decodeDepthParams);
        float3 centerWS = ray.centerDirWS * t + ray.originWS;
        float3 radiance = 0;

        float3 scattering = 0.05;
        float extinction = 0.05;

        // Perform per-pixel randomization by adding an offset and then sampling uniformly
        // (in the log space) in a vein similar to Stochastic Universal Sampling:
        // https://en.wikipedia.org/wiki/Stochastic_universal_sampling
        float perPixelRandomOffset = GenerateHashedRandomFloat(centerCoord);

    #ifdef ENABLE_REPROJECTION
        // This is a time-based sequence of 7 equidistant numbers from 1/14 to 13/14.
        // Each of them is the centroid of the interval of length 2/14.
        float rndVal = frac(perPixelRandomOffset + _VBufferSampleOffset.z);
    #else
        float rndVal = frac(perPixelRandomOffset + 0.5);
    #endif


        VoxelLighting aggregateLighting;
        ZERO_INITIALIZE(VoxelLighting, aggregateLighting);

        // Prevent division by 0.
        extinction = max(extinction, FLT_MIN);

        float sampleOpticalDepth = extinction * dt;
        float sampleTransmittance = exp(-sampleOpticalDepth);

        // TODO: Directional

        // Local
        {
            VoxelLighting lighting = EvaluateVoxelLightingLocal(centerCoord, extinction, anisotropy,
                                                                ray, t0, t1, dt, centerWS, rndVal);
            aggregateLighting.radianceNoPhase  += lighting.radianceNoPhase;
            aggregateLighting.radianceComplete += lighting.radianceComplete;
        }


        float phase = CornetteShanksPhasePartConstant(anisotropy); // or rcp(4.0 * PI)
        float4 blendValue = float4(aggregateLighting.radianceComplete,  extinction * dt);
        totalRadiance += throughput * scattering * (phase * blendValue.rgb);
        opticalDepth += 0.5 * blendValue.a;

        throughput *= sampleTransmittance;

        if (t0 * 0.99 > ray.maxDist)
        {
            break;
        }
        t0 = tNext;
    }

    _VBufferLightingOutput[dispatchThreadId] = float4(totalRadiance, opticalDepth);
}
